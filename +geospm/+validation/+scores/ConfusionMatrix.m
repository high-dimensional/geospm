% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %
%                                                                         %
%  This source file is part of GeoSPM:                                    %
%  https://github.com/high-dimensional/geospm                             %
%                                                                         %
%  Copyright (C) 2022,                                                    %
%  High-Dimensional Neurology Group, University College London            %
%                                                                         %
%  See geospm/LICENSE.txt for license details.                            %
%  See geospm/AUTHORS.txt for the list of GeoSPM authors.                 %
%                                                                         %
%  SPDX-License-Identifier: GPL-3.0-only                                  %
%                                                                         %
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % % %

classdef ConfusionMatrix < geospm.validation.scores.ImageScore
    %ConfusionMatrix Computes the intersection over union.
    %   Takes the variable names of an experiment's data.
    
    properties
    end
    
    methods
        
        function obj = ConfusionMatrix()
            obj = obj@geospm.validation.scores.ImageScore();
            
            obj.score_identifiers = { 'score.tp', ...
                                      'score.tn', ...
                                      'score.fp', ...
                                      'score.fn', ...
                                      'score.tpr', ...
                                      'score.fpr', ...
                                      'score.fnr', ...
                                      'score.tnr', ...
                                      'score.ppv', ...
                                      'score.fdr', ...
                                      'score.for', ...
                                      'score.npv', ...
                                      'score.lrp', ...
                                      'score.lrn', ...
                                      'score.dor', ...
                                      'score.f1',  ...
                                      'score.dice', ...
                                      'score.jaccard_index', ...
                                      'score.prevalence', ...
                                      'score.acc', ...
                                      'score.mcc', ...
                                      'score.bm', ...
                                      'score.mk', ...
                                      'score.gce', ...
                                      'score.mi', ...
                                      'score.su', ...
                                      'score.voi', ...
                                      'score.auc', ...
                                      'score.kappa', ...
                                      'score.ri', ...
                                      'score.ari' };
                                  
            obj.score_descriptions = { 'True Positives', ...
                                       'True Negatives', ...
                                       'False Positives', ...
                                       'False Negatives', ...
                                       'True Positive Rate', ...
                                       'False Positive Rate', ...
                                       'False Negative Rate', ...
                                       'True Negative Rate', ...
                                       'Positive Predictive Value', ...
                                       'False Discovery Rate', ...
                                       'False Omission Rate', ...
                                       'Negative Predictive Value', ...
                                       'Positive Likelihood Ratio', ...
                                       'Negative Likelihood Ratio', ...
                                       'Diagnostic Odds Ratio', ...
                                       'F1 Score', ...
                                       'DICE Score', ...
                                       'Jaccard Index (Confusion Matrix)', ...
                                       'Prevalence', ...
                                       'Accuracy', ...
                                       'Matthews Correlation Coefficient', ...
                                       'Informedness', ...
                                       'Markedness', ...
                                       'Global Consistency Error', ...
                                       'Mutual Information', ...
                                       'Symmetric Uncertainty', ...
                                       'Variation of Information', ...
                                       'Area under Curve', ...
                                       'Cohen Kappa Coefficient', ...
                                       'Rand Index', ...
                                       'Adjusted Rand Index' };
        end
        
        function result = compute_scores_for_slice(~, target_z, target_slice, result_z, result_slice) %#ok<INUSL>
            
            
            tp_slice = bitand(target_slice, result_slice);
            tn_slice = bitand(~target_slice, ~result_slice);
            
            fp_slice = bitand(~target_slice, result_slice);
            fn_slice = bitand(target_slice, ~result_slice);
            
            n = numel(target_slice);
            
            TP = sum(tp_slice(:));
            TN = sum(tn_slice(:));
            FP = sum(fp_slice(:));
            FN = sum(fn_slice(:));
            
            COND_POSITIVE = TP + FN;
            COND_NEGATIVE = TN + FP;
            
            TEST_POSITIVE = TP + FP;
            TEST_NEGATIVE = TN + FN;
            
            TPR = TP / COND_POSITIVE;
            FPR = FP / COND_NEGATIVE;
            FNR = FN / COND_POSITIVE;
            TNR = TN / COND_NEGATIVE;
            PPV = TP / TEST_POSITIVE;
            FDR = FP / TEST_POSITIVE;
            FOR = FN / TEST_NEGATIVE;
            NPV = TN / TEST_NEGATIVE;
            LRP = TPR / FPR;
            LRN = FNR / TNR;
            DOR = LRP / LRN;
            
            %F1 = 2.0 * PPV * TPR / (PPV + TPR);
            F1 = TP / (TP + 0.5 * (FP + FN));
            
            F1(isnan(F1)) = 0.0;
            
            PRE = COND_POSITIVE / (COND_POSITIVE + COND_NEGATIVE);
            ACC = (TP + TN) / (COND_POSITIVE + COND_NEGATIVE);
            
            denom = sqrt(TEST_POSITIVE * COND_POSITIVE * COND_NEGATIVE * TEST_NEGATIVE);
            MCC = (TP * TN - FP * FN) / denom;
            
            MCC(isnan(MCC)) = 0.0;
            
            BM = TPR + TNR - 1;
            MK = PPV + NPV - 1;
            
            %The following measures are taken from
            %https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4533825
            
            gce1 = FN * (FN + 2.0 * TP) / COND_POSITIVE ...
                    + FP * (FP + 2.0 * TN) / COND_NEGATIVE;
            
            gce2 =  FP * (FP + 2.0 * TP) / TEST_POSITIVE ...
                    + FN * (FN + 2.0 * TN) / TEST_NEGATIVE;
            
            GCE = min(gce1, gce2) / n;
            
            P_TP = TP / n;
            P_TN = TN / n;
            P_FP = FP / n;
            P_FN = FN / n;
            
            CONFUSION_P = [P_TP; 
                           P_TN;
                           P_FP;
                           P_FN];
            
            LOG_CONFUSION_P = log(CONFUSION_P);
            LOG_CONFUSION_P(isinf(LOG_CONFUSION_P)) = 0.0;
            
            P_COND_POSITIVE = COND_POSITIVE / n;
            P_COND_NEGATIVE = COND_NEGATIVE / n;
            P_TEST_POSITIVE = TEST_POSITIVE / n;
            P_TEST_NEGATIVE = TEST_NEGATIVE / n;
            
            MARGINAL_P = [P_COND_POSITIVE; 
                          P_COND_NEGATIVE;
                          P_TEST_POSITIVE;
                          P_TEST_NEGATIVE];
            
                      
            LOG_MARGINAL_P = log(MARGINAL_P);
            LOG_MARGINAL_P(isinf(LOG_MARGINAL_P)) = 0.0;
            
            MI = - (MARGINAL_P' * LOG_MARGINAL_P) ...
                 + CONFUSION_P' * LOG_CONFUSION_P;
            
            %Symmetric Uncertainty
            SU = 2.0 * MI / (- (MARGINAL_P' * LOG_MARGINAL_P));
             
            %{
            MI = - P_COND_POSITIVE * log(P_COND_POSITIVE) ...
                 - P_COND_NEGATIVE * log(P_COND_NEGATIVE) ...
                 - P_TEST_POSITIVE * log(P_TEST_POSITIVE) ...
                 - P_TEST_NEGATIVE * log(P_TEST_NEGATIVE) ...
                 + P_TP * log(P_TP) ...
                 + P_TN * log(P_TN) ...
                 + P_FP * log(P_FP) ...
                 + P_FN * log(P_FN);
            %}
            
            VOI =   MARGINAL_P' * LOG_MARGINAL_P ...
                 -2.0 * (CONFUSION_P' * LOG_CONFUSION_P); 
                 
            %{
            VOI = + P_COND_POSITIVE * log(P_COND_POSITIVE) ...
                  + P_COND_NEGATIVE * log(P_COND_NEGATIVE) ...
                  + P_TEST_POSITIVE * log(P_TEST_POSITIVE) ...
                  + P_TEST_NEGATIVE * log(P_TEST_NEGATIVE) ...
                  - 2.0 * P_TP * log(P_TP) ...
                  - 2.0 * P_TN * log(P_TN) ...
                  - 2.0 * P_FP * log(P_FP) ...
                  - 2.0 * P_FN * log(P_FN);
            %}
            
            % Area under Curve as in https://arxiv.org/pdf/2010.16061.pdf
            AUC = 1 - (FPR + FNR) / 2.0;
            
            fa = TP + TN;
            fc = (TEST_NEGATIVE * COND_NEGATIVE + TEST_POSITIVE * COND_POSITIVE) / n;
            KAP = (fa - fc) / (n - fc);
            
            a = (TP * (TP - 1.0) + FP * (FP - 1.0) + TN * (TN - 1.0) + FN * (FN - 1)) / 2.0;
            b = (COND_POSITIVE^2 + COND_NEGATIVE^2 - (TP^2 + TN^2 + FP^2 + FN^2)) / 2.0;
            c = (TEST_POSITIVE^2 + TEST_NEGATIVE^2 - (TP^2 + TN^2 + FP^2 + FN^2)) / 2.0;
            d = n * (n - 1) / 2.0 - (a + b + c);
            
            RI = (a + b) / (a + b + c + d);
            ARI = 2 * (a * d - b * c) / (c^2 + b^2 + 2 * a * d + (a + d) * (c + b));
            
            JAC = TP / (TP + FP + FN);
            
            if isnan(JAC)
                JAC = 0.0;
            end
            
            result = [TP,  TN,  FP,  FN,  ...
                      TPR, FPR, FNR, TNR, ...
                      PPV, FDR, FOR, NPV, ...
                      LRP, LRN, DOR, F1,  ...
                      F1,  JAC, PRE, ACC, ...
                      MCC, BM,  MK,  GCE, ...
                      MI,  SU,  VOI, AUC, ...
                      KAP, RI,  ARI];
        end
        
    end
    
    
    methods (Access=protected)
        
        function result = compute_identifier(~)
            result = 'confusion_matrix';
        end
    end
end
